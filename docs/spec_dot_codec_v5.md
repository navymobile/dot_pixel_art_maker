# DotCodec v5 仕様書

## 概要

DotCodec v5 は、ドット絵のピクセルデータと系譜情報（lineage）を Base64URL ペイロードとしてエンコード／デコードするためのフォーマットである。
v4 をベースに、新たに **RGB444（4096色 + 透明）** エンコーディングを追加し、描画体験と圧縮効率のバランスを改善する。

## 前提

- パレット定義はペイロードに含めない。
- Base64URL は padding 無し（`=` 除去）で統一。
- 既存の v3（RGBA5551 固定、ヘッダなし）は legacy として残す。
- 既存の v4 コード（`[v=4][e][w][h]`、e=1/e=2）もテスト用に維持する。

## データ構造

### 1. ヘッダ (4 bytes)

先頭の 4 バイトはバージョン、エンコーディングタイプ、および画像の寸法を定義する。

| Offset | Len | Type  | Description                                    |
| :----- | :-- | :---- | :--------------------------------------------- |
| 0      | 1   | uint8 | **Version (v)**: `5` 固定                      |
| 1      | 1   | uint8 | **Encoding (e)**: `1`, `2`, or `3`（下表参照） |
| 2      | 1   | uint8 | **Width (w)**: ピクセル幅（例: 16, 21, 25）    |
| 3      | 1   | uint8 | **Height (h)**: ピクセル高さ（例: 16, 21, 25） |

#### エンコーディングタイプ一覧

| e   | 名称     | ビット/px | 色数     | 透明の扱い     |
| :-- | :------- | :-------- | :------- | :------------- |
| 1   | RGBA5551 | 16        | 32,768色 | 1bit Alpha     |
| 2   | Indexed8 | 8         | 256色    | Index 0 = 透明 |
| 3   | RGB444   | 12        | 4,096色  | 0x000 = 透明   |

### 2. ペイロードボディ (Variable Length)

エンコーディングタイプに応じてピクセルデータの形式が変わる。

#### Type 1: RGBA5551

- **Pixels**: `2 * (w * h)` bytes
  - 16-bit integer (RGBA 5-5-5-1) Big Endian

#### Type 2: Indexed8

- **Pixels**: `1 * (w * h)` bytes
  - 8-bit integer (Index)
  - `0`: 透明 (Alpha = 0)
  - `1..255`: RGB332 量子化カラー

#### Type 3: RGB444 (Packed 12bit)

- **Pixels**: `ceil(w * h * 12 / 8)` bytes
  - 12-bit integer (R4 G4 B4) を MSB-first でビットパック
  - `0x000`: 透明 (Alpha = 0) — **予約値**
  - `0x001..0xFFF`: 不透明カラー (Alpha = 255)
- **パッキング方式**: MSB-first ビットストリーム
  - RGB444 は 12bit 値を左詰めで連結したビット列を、先頭から 8bit ずつ切り出して格納する（MSB-first）。
  - Pixel 0 の上位4bit → byte[0] の bit7..4
  - Pixel 0 の下位8bit → byte[0] の bit3..0 + byte[1] の bit7..4
  - Pixel 1 の上位8bit → byte[1] の bit3..0 + byte[2] の bit7..4
  - Pixel 1 の下位4bit → byte[2] の bit3..0
  - …以降繰り返し（2ピクセル = 3バイト）

#### 共通フッタ

- **Count**: 1 byte (Lineage 数 `N`, max 255)
- **Lineage**: `16 * N` bytes (16 bytes per entry)

> [!NOTE]
> **Lineage 上限**: v5 では `N` の上限は 255 とする。
> v3 legacy decode 時に `count > 20` の場合は `FormatException` とする（データ破損とみなす）。

### 3. CRC32 (4 bytes)

| Offset | Len | Type   | Description                                    |
| :----- | :-- | :----- | :--------------------------------------------- |
| End-4  | 4   | uint32 | **CRC32**: Big Endian of Header + Payload Body |

- **計算対象**: ヘッダ(4 bytes) + ペイロードボディの全データ（`data[0 .. totalLength - 4]`）。
- **除外対象**: 自分自身（末尾の CRC32 フィールド）。

> [!NOTE]
> v4 も CRC32 は末尾 4 バイトを除く全体（ヘッダ含む）を対象とする。v4 と v5 の CRC 計算方式は同一である。

## 全体レイアウト

```
[ v (1) ][ e (1) ][ w (1) ][ h (1) ][ Pixels (Var) ][ Count (1) ][ Lineage (16*N) ][ CRC32 (4) ]
```

### ペイロードサイズ計算

P = w \* h（ピクセル数）

| e   | Pixels サイズ            | 合計（Lineage 無し）     |
| :-- | :----------------------- | :----------------------- |
| 1   | `2 * P` bytes            | `4 + 2P + 1 + 4`         |
| 2   | `P` bytes                | `4 + P + 1 + 4`          |
| 3   | `ceil(P * 12 / 8)` bytes | `4 + ceil(1.5P) + 1 + 4` |

#### 具体例（21x21 = 441px, Lineage 0件）

| e   | Pixels    | 合計      |
| :-- | :-------- | :-------- |
| 1   | 882 bytes | 891 bytes |
| 2   | 441 bytes | 450 bytes |
| 3   | 662 bytes | 671 bytes |

## RGB444 量子化仕様

### エンコード（ARGB32 → RGB444）

1. `alpha == 0` の場合: `rgb12 = 0x000`（透明）
2. `alpha != 0` の場合:
   - `r4 = (r8 * 15 + 127) ~/ 255`
   - `g4 = (g8 * 15 + 127) ~/ 255`
   - `b4 = (b8 * 15 + 127) ~/ 255`
   - `rgb12 = (r4 << 8) | (g4 << 4) | b4`
   - **透明予約対策**: `rgb12 == 0x000` の場合は `0x001` に置換する

> [!NOTE]
> 純黒 (`#000000`) は厳密には表現されず、`0x001` に寄る。
> デコード時 `0x001` → `R=0, G=0, B=17` (`#000011`) となるが、ドット絵としては視覚的にほぼ黒である。

### デコード（RGB444 → ARGB32）

1. `rgb12 == 0x000`: `ARGB = 0x00000000`（透明）
2. `rgb12 != 0x000`:
   - `r4 = (rgb12 >> 8) & 0x0F`
   - `g4 = (rgb12 >> 4) & 0x0F`
   - `b4 = rgb12 & 0x0F`
   - `r8 = (r4 * 255 + 7) ~/ 15`
   - `g8 = (g4 * 255 + 7) ~/ 15`
   - `b8 = (b4 * 255 + 7) ~/ 15`
   - `ARGB = 0xFF000000 | (r8 << 16) | (g8 << 8) | b8`

## エンコーディング / デコーディング フロー

### Encoding (v5)

1. `v=5` をセット。
2. 指定された `e` (1, 2, or 3) をセット。
3. 現在の `AppConfig.dots` を `w`, `h` にセット。
4. ピクセルデータを `e` に応じてエンコードして追加。
5. Lineage データを追加。
6. ここまでのバイト列に対して CRC32 を計算し、末尾に付与。
7. Base64URL (padding なし) でエンコード。

### Decoding (Strategy)

フォールバックは **形式不正（長さ不整合・unknown e・先頭バイト不一致）** の場合のみ行う。
ヘッダを読めて構造が成立するにもかかわらず CRC32 が不一致の場合は **データ破損** とみなし、他バージョンへのフォールバックは行わず `FormatException` を投げる。

1. **Try v5 Decode:**
   - Base64URL デコードを行う。
   - データ長が最小要件（`Header(4) + Count(1) + CRC(4) = 9 bytes`）を満たすか確認。
   - 先頭バイトが `5` でなければ → 手順 2 へ。
   - `e`, `w`, `h` を読み取る。
   - ピクセルデータ長を計算し、全体サイズが整合するか確認。
     - **長さ不整合 / unknown e** → 手順 2 へ（形式不正）。
   - 末尾の CRC32 を検証。
     - **CRC 一致**: `v5` として確定。`e` の値に従ってピクセルを展開。
     - **CRC 不一致**: `FormatException` を投げる（**破損。フォールバックしない**）。
2. **Try v4 Decode (テスト互換):**
   - 先頭バイトが `4` でなければ → 手順 3 へ。
   - v4 の仕様に従って構造検証。
     - **構造不正** → 手順 3 へ。
   - CRC32 を検証。
     - **CRC 一致**: v4 として確定。
     - **CRC 不一致**: `FormatException` を投げる（**破損。フォールバックしない**）。
3. **Fallback to v3 (Legacy) Decode:**
   - ヘッダなしの v3 形式として decode を試行。
   - Lineage count が 20 を超える場合は `FormatException`（データ破損とみなす）。
   - CRC32 を検証。
     - **CRC 一致**: v3 として確定。
     - **CRC 不一致 / 形式不正**: `FormatException` を投げる。

> [!CAUTION]
> **CRC 不一致 = データ破損**。構造が成立している状態での CRC 不一致は、別バージョンへのフォールバックでは回復できないため、即座にエラーとする。

## AppConfig との連携

### 保存時

| `AppConfig.pixelEncoding` | 使用するエンコーダ |
| :------------------------ | :----------------- |
| `'rgba5551'`              | v5 e=1             |
| `'indexed8'`              | v5 e=2             |
| `'rgb444'`                | v5 e=3             |

> [!IMPORTANT]
> **新規保存はすべて v5 形式で行う。** v3 は decode 専用の legacy とし、新規に v3 データを生成しない。
> これにより将来的なフォーマット移行が容易になる。

### 読込時

`DotCodec.decode()` を使用（v5 → v4 → v3 自動フォールバック）。保存形式に依存しない。

## 受け入れ条件（テスト）

- `pixelEncoding='rgb444'` の状態で、描画→保存→再読込→ホーム表示が同一（透明含む）で復元される。
- 既存の v3 データも問題なく読める。
- 既存の v4 データも問題なく読める。
- CRC 不一致のデータは v5/v4/v3 含めて復号できず、`FormatException` になる。
- RGB444 量子化で透明ピクセルが正しく保存・復元される。
- RGB444 量子化で純黒に近い色が `0x001` に正しく置換される。
